(defpackage :queue-test
  (:use :cl :lisp-unit2))
(in-package :queue-test)

(defun perf-time ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (let* ((repitions (* 10000000))
         (start (get-internal-real-time)))
    (do ((i 0 (1+ i)))
        ((= i repitions))
      (declare (type fixnum i))
      (unless (<= (get-internal-real-time) (get-internal-real-time))
        (print "wrong")))
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))
(defun perf-run-time ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (let* ((repitions (* 10000000))
         (start (get-internal-real-time)))
    (do ((i 0 (1+ i)))
        ((= i repitions))
      (declare (type fixnum i))
      (unless (<= (get-internal-run-time) (get-internal-run-time))
        (print "wrong")))
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))

(defun perf-rep ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((iterations 10000000000))
    (do ((rep iterations (1- rep))
         (start (get-internal-real-time)))
        ((zerop rep) (round (/ (* 1000 iterations)
                               (- (get-internal-real-time) start))))
      (declare (type fixnum rep)))))

(defun perf-random ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((iterations 10000000))
    (do ((rep iterations (1- rep))
         (start (get-internal-real-time)))
        ((zerop rep) (round (/ (* 1000 iterations)
                               (- (get-internal-real-time) start))))
      (declare (type fixnum rep))
      (random 333))))

(defun perf-test ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((stopped? t))
    (declare (type boolean stopped?))
    (let ((thr (bt:make-thread (lambda ()
                                 (do ()
                                     ((not stopped?)
                                      (do ((runs 0 (1+ runs)))
                                          (stopped? runs)
                                        (declare (type fixnum runs)))))))))
      (sleep 0.001)
      (setf stopped? nil)
      (time (sleep 1))
      (setf stopped? t)
      (bt:join-thread thr))))

(defun perf-mailbox-test ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((stopped? t))
    (declare (type boolean stopped?))
    (let ((thr (bt:make-thread (lambda ()
                                 (do ((queue (sb-concurrency:make-mailbox)))
                                     ((not stopped?)
                                      (do ((runs 0 (1+ runs)))
                                          (stopped? runs)
                                        (declare (type fixnum runs))
                                        (sb-concurrency:send-message queue 1)
                                        (sb-concurrency:receive-message queue))))))))
      (sleep 0.001)
      (setf stopped? nil)
      (time (sleep 1))
      (setf stopped? t)
      (bt:join-thread thr))))

(defun perf-list-test ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((stopped? t))
    (declare (type boolean stopped?))
    (let ((thr (bt:make-thread (lambda ()
                                 (do ((queue (list)))
                                     ((not stopped?)
                                      (do ((runs 0 (1+ runs)))
                                          (stopped? runs)
                                        (declare (type fixnum runs))
                                        (push 1 queue)
                                        (pop queue))))))))
      (sleep 0.001)
      (setf stopped? nil)
      (time (sleep 1))
      (setf stopped? t)
      (bt:join-thread thr))))

(defun perf-queue-test ()
  (declare (optimize (speed 3) (safety 0)))
  (let* ((repitions (* 10000000))
         (test-value 777)
         (queue (sb-concurrency:make-mailbox))
         (start (get-internal-real-time))
         (producer (bt:make-thread (lambda ()
                                     (do ((i 0 (1+ i)))
                                         ((= i repitions))
                                       (declare (type fixnum i))
                                       (do ((result (not (sb-concurrency:send-message queue test-value)) (not (sb-concurrency:send-message queue test-value))))
                                           (result)
                                         (bt:thread-yield)))))))
    (do ((i 0 (1+ i)))
        ((= i repitions))
      (declare (type fixnum i))
      (do ((result (sb-concurrency:receive-message-no-hang queue) (sb-concurrency:receive-message-no-hang queue)))
          (result)
        (bt:thread-yield)))
    (bt:join-thread producer)
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))

(defun perf-list2-test ()
  (declare (optimize (speed 3) (safety 0)))
  (let* ((repitions (* 10000000))
         (test-value 777)
         (queue (list))
         (start (get-internal-real-time)))
    (declare (type list queue))
    (let ((producer (bt:make-thread (lambda ()
                                      (do ((i 0 (1+ i)))
                                          ((= i repitions))
                                        (declare (type fixnum i))
                                        (do ((result (push test-value queue) (push test-value queue)))
                                            (result)
                                          (bt:thread-yield)))))))
      (do ((i 0 (1+ i)))
          ((= i repitions))
        (declare (type fixnum i))
        (do ((result (pop queue) (pop queue)))
            (result)
          (bt:thread-yield)))
      (bt:join-thread producer))
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))

(defstruct conc
  (buffer #() :type simple-vector)
  (mask 0 :type fixnum)
  (size 0 :type fixnum)
  p1 p2 p3 p4 p5
  (tail 0 :type fixnum)
  r1 r2 r3 r4 r5
  (head 0 :type fixnum))

(defun make-array-queue (capacity)
  (let ((size (expt 2 (ceiling (log capacity 2)))))
    (make-conc :mask (1- size) :size size :buffer (make-array (list size) :initial-element nil))))

(defun offer (queue value)
  (declare (optimize (speed 3) (safety 0) (space 0) (compilation-speed 0) (debug 0)))
  (sb-thread:barrier (:read)
    (if (null value)
        (error 'nil-value)
        (let* ((tail (conc-tail queue))
               (size (conc-size queue))
               (wrap (- tail size)))
          (declare (type fixnum tail size wrap))
          (if (<= (conc-head queue) wrap)
              nil
              (progn
                (setf (svref (conc-buffer queue) (logand tail (conc-mask queue))) value)
                (incf (conc-tail queue))))))))

(defun take (queue)
  (declare (optimize (speed 3) (safety 0) (space 0) (compilation-speed 0) (debug 0)))
  (sb-thread:barrier (:read)
    (let ((head (conc-head queue)))
      (if (>= head (conc-tail queue) 0)
          nil
          (let* ((index (logand head (conc-mask queue)))
                 (e (svref (conc-buffer queue) index)))
            (setf (svref (conc-buffer queue) index) nil)
            (incf (conc-head queue))
            e)))))

(defun perf-single-thread-array-test ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (let* ((repitions (* 100000000))
         (queue (make-array-queue (* 32 1024)))
         (start (get-internal-real-time)))
    (do ((i 0 (1+ i)))
        ((= i repitions))
      (declare (type fixnum i))
      (do ()
          ((offer queue i)))
      (do ()
          ((take queue))))
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))


(defun perf-array-test ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (sb-ext:gc :full t)
  (let* ((repitions (* 100000000))
         (queue (make-array-queue (* 32 1024)))
         (start (get-internal-real-time)))
    (let ((producer (bt:make-thread (lambda ()
                                      (do ((i repitions (1- i)))
                                          ((zerop i))
                                        (declare (type fixnum i))
                                        (do ()
                                            ((offer queue i))
                                          ;; better result than
                                          ;; bt:thread-yield
                                          (sleep 0.0000001)))))))
      (do ((i repitions (1- i)))
          ((zerop i))
        (declare (type fixnum i))
        (do ()
            ((take queue))
          (sleep 0.0000001)))
      (bt:join-thread producer))
    (let* ((duration (- (get-internal-real-time) start))
           (ops (round (/ (* repitions 1000) duration))))
      (format t "ops/sec=~a -" ops))))

(defstruct dis
  (buffer #() :type simple-vector)
  (mask 0 :type fixnum)
  (size 0 :type fixnum)
  (cached-min 0 :type fixnum)
  p1 p2 p3 p4 p5
  (cursor 0 :type fixnum)
  r1 r2 r3 r4 r5
  (readers (list) :type list))

(defstruct reader
  (cursor 0 :type fixnum)
  p1 p2 p3 p4 p5
  (offset 1 :type fixnum)
  dis)

(defun make-disruptor (capacity)
  (let ((size (expt 2 (ceiling (log capacity 2)))))
    (make-dis :mask (1- size) :size size :buffer (make-array (list size) :initial-element nil))))

(defun write-dis (dis value)
  (declare (optimize (speed 3) (safety 0) (space 0) (compilation-speed 0) (debug 0)))
  (if (null value)
      (error 'nil-value)
      (let* ((cursor (dis-cursor dis))
             (size (dis-size dis))
             (wrap (- cursor size)))
        (declare (type fixnum cursor size wrap))
        (if (<= (dis-cached-min dis) wrap)
            (let ((min (expt 2 61)))
              (declare (type fixnum min))
              (dolist (reader (dis-readers dis))
                (setf min (min min (reader-cursor reader))))
              (setf (dis-cached-min dis) min)
              (if (<= min wrap)
                  nil
                  (progn
                    (setf (svref (dis-buffer dis) (logand cursor (dis-mask dis))) value)
                    (incf (dis-cursor dis)))))
            (progn
              (setf (svref (dis-buffer dis) (logand cursor (dis-mask dis))) value)
              (incf (dis-cursor dis)))))))

(defun read-dis (reader)
  (declare (optimize (speed 3) (safety 0) (space 0) (compilation-speed 0) (debug 0)))
  (let ((head (reader-cursor reader))
        (dis (reader-dis reader)))
    (if (>= head (dis-cursor dis))
        nil
        (let* ((index (logand head (dis-mask dis)))
               (e (svref (dis-buffer dis) index)))
          (setf (svref (dis-buffer dis) index) nil)
          (incf (reader-cursor reader) (reader-offset reader))
          e))))

(defun make-dis-reader (dis &optional (start 0) (offset 1))
  (let ((r (make-reader :dis dis :cursor start :offset offset)))
    (push r (dis-readers dis))
    r))

(defun perf-disruptor-test ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (sb-ext:gc :full t)
  (let* ((repitions (* 100000000))
         (queue (make-disruptor (* 32 1024)))
         (reader1 (make-dis-reader queue 0 4))
         (reader2 (make-dis-reader queue 1 4))
         (reader3 (make-dis-reader queue 2 4))
         (reader4 (make-dis-reader queue 3 4)))
    (let ((consumer4 (bt:make-thread (lambda ()
                                      (do ((i repitions (- i 4)))
                                          ((zerop i))
                                        (declare (type fixnum i))
                                        (do ()
                                            ((read-dis reader4))
                                          (sleep 0.0000001))))))
          (consumer1 (bt:make-thread (lambda ()
                                       (do ((i repitions (- i 4)))
                                           ((zerop i))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((read-dis reader1))
                                           (sleep 0.0000001))))))
          (consumer2 (bt:make-thread (lambda ()
                                       (do ((i repitions (- i 4)))
                                           ((zerop i))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((read-dis reader2))
                                           (sleep 0.0000001))))))
          (consumer3 (bt:make-thread (lambda ()
                                       (do ((i repitions (- i 4)))
                                           ((zerop i))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((read-dis reader3))
                                           (sleep 0.0000001)))))))
      (sleep 0.01)
      (let ((start (get-internal-real-time)))
        (do ((i repitions (1- i)))
            ((zerop i))
          (declare (type fixnum i))
          (do ()
              ((write-dis queue i))
            ;; better result than
            ;; bt:thread-yield
            (sleep 0.0000001)))
        (bt:join-thread consumer4)
        (bt:join-thread consumer1)
        (bt:join-thread consumer2)
        (bt:join-thread consumer3)
        (let* ((duration (- (get-internal-real-time) start))
               (ops (round (/ (* repitions 1000) duration))))
          (format t "ops/sec=~a -" ops))))))

(defun perf-event-test ()
  (declare (optimize (speed 3) (safety 0)))
  (sb-ext:gc :full t)
  (sb-ext:gc :full t)
  (let* ((repitions 1000000000)
         (queue (make-array-queue (* 32 1024)))
         (cqueue1 (make-array-queue (* 16 1024)))
         (cqueue2 (make-array-queue (* 16 1024)))
         (cqueue3 (make-array-queue (* 16 1024)))
         (cqueue4 (make-array-queue (* 16 1024)))
         (cqueue5 (make-array-queue (* 16 1024)))
         (cqueue6 (make-array-queue (* 16 1024)))
         (cqueue7 (make-array-queue (* 16 1024))))
    (let ((consumer1 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue1))
                                           (sleep 0.0000001))))))
          (consumer2 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue2))
                                           (sleep 0.0000001))))))
          (consumer3 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue3))
                                           (sleep 0.0000001))))))
          (consumer4 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue4))
                                           (sleep 0.0000001))))))
          (consumer5 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue5))
                                           (sleep 0.0000001))))))
          (consumer6 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue6))
                                           (sleep 0.0000001))))))
          (consumer7 (bt:make-thread (lambda ()
                                       (do ((i 0 (+ 7 i)))
                                           ((>= i repitions))
                                         (declare (type fixnum i))
                                         (do ()
                                             ((take cqueue7))
                                           (sleep 0.0000001)))))))
      (sleep 0.5)
      (let ((start (get-internal-real-time)))
        (do ((i 0 (+ 7000 i)))
            ((>= i repitions))
          (declare (type fixnum i))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue2 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue3 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue4 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue5 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue1 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue6 i))))
          (do ((j 0 (1+ j)))
              ((= j 1000))
            (declare (type fixnum j))
            (do ()
                ((offer cqueue7 i)))))
        (bt:join-thread consumer1)
        (bt:join-thread consumer2)
        (bt:join-thread consumer3)
        (bt:join-thread consumer4)
        (bt:join-thread consumer5)
        (bt:join-thread consumer6)
        (bt:join-thread consumer7)
        (let* ((duration (- (get-internal-real-time) start))
               (ops (round (/ (* repitions 1000) duration))))
          (format t "ops/sec=~a -" ops))))))

